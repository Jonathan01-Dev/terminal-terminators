import json
import os
from cryptography.hazmat.primitives import serialization

TRUSTED_FILE = "trusted_peers.json"


def load_trusted_peers():
    if not os.path.exists(TRUSTED_FILE):
        return {}
    with open(TRUSTED_FILE, "r") as f:
        return json.load(f)


def save_trusted_peers(data):
    with open(TRUSTED_FILE, "w") as f:
        json.dump(data, f, indent=4)


def public_key_to_pem_string(public_key):
    pem = public_key.public_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo
    )
    return pem.decode("utf-8")


def verify_or_save_peer(peer_id, received_public_key):
    """
    VÃ©rifie la clÃ© dâ€™un pair avec TOFU.
    - PremiÃ¨re connexion â†’ sauvegarde
    - Connexion suivante â†’ compare
    - Si diffÃ©rente â†’ alerte MITM
    """

    trusted_peers = load_trusted_peers()
    received_pem = public_key_to_pem_string(received_public_key)

    if peer_id not in trusted_peers:
        print(f"ğŸ” PremiÃ¨re connexion avec {peer_id}")
        trusted_peers[peer_id] = received_pem
        save_trusted_peers(trusted_peers)
        print("âœ… ClÃ© publique enregistrÃ©e (TOFU).")
        return True

    # VÃ©rification clÃ© existante
    if trusted_peers[peer_id] == received_pem:
        print("âœ… ClÃ© vÃ©rifiÃ©e. Connexion sÃ©curisÃ©e.")
        return True
    else:
        print("âš ï¸ ALERTE : La clÃ© publique a changÃ© !")
        print("ğŸš¨ Possible attaque Man-In-The-Middle (MITM).")

        response = input("Voulez-vous accepter la nouvelle clÃ© ? (oui/non) : ")

        if response.lower() == "oui":
            trusted_peers[peer_id] = received_pem
            save_trusted_peers(trusted_peers)
            print("ğŸ”„ Nouvelle clÃ© enregistrÃ©e.")
            return True
        else:
            print("âŒ Connexion refusÃ©e.")
            return False